<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<title>Assignment 2: Reinforcement Learning</title>
<link type="text/css" rel="stylesheet" href="projects.css"/>
</head>

<body>

<h2>Project 3: Reinforcement Learning</h2>
<p>Due July 27</p>
<!--announcements-->

<blockquote>
<center>
<img src="capsule.png" width="50%" alt="capsuleClassic layout"/>
</center>
  <p><cite><center>Pac-Man seeks reward.<br>
  Should he eat or should he run?<br>
  When in doubt, q-learn.</center></cite></p>
</blockquote>

<h3>Introduction</h3>

<p>In this project, you will implement value iteration and q-learning. You will test your agents first on Gridworld (from class), then apply them to a simulated robot controller (Crawler) and Pac-Man.</p>

<p>The code for this project contains the following files, which are available in a <a href="reinforcement.zip">zip archive</a>:</p>

<h5><b> Files you will edit </b></h5>

<table border="0" cellpadding="10">

<tr>
<td><code><a href="docs/valueIterationAgents.html">valueIterationAgents.py</a></code></td>
<td>A value iteration agent for solving known MDPs.</td>
</tr>

<tr>
<td><code><a href="docs/qlearningAgents.html">qlearningAgents.py</a></code></td>
<td>Q-learning agents for Gridworld, Crawler and Pac-Man</td>
</tr>

<tr>
<td><code><a href="docs/analysis.html">analysis.py</a></code></td>
<td>A file to put your answers to questions given in the project.</td>
</tr>

</table>

<h5><b>Files you should read but NOT edit</b></h5>


<table border="0" cellpadding="10">
<tr>
<td><code><a href="docs/mdp.html">mdp.py</a></code></td>


<td>Defines methods on general MDPs. </td>

</tr>

<tr>
<td><code><a href="docs/learningAgents.html">learningAgents.py</a></code></td>
<td>Defines the base classes <code>ValueEstimationAgent</code> and <code>QLearningAgent</code>, which your agents will extend.</td>
</tr>

<tr>

<td><code><a href="docs/util.html">util.py</a></code></td>

<td>Utilities, including <code>util.Counter</code>, which is particularly useful for q-learners.</td>

</tr>


<td><code><a href="docs/gridworld.html">gridworld.py</a></code></td>

<td>The Gridworld implementation</td>

</tr>


<tr>
<td><code><a href="docs/featureExtractors.html">featureExtractors.py</a></code></td>
<td>Classes for extracting features on (state,action) pairs. Used
	for the approximate q-learning agent (in qlearningAgents.py).</td>
</tr>


</table>
<h5><b>Files you can ignore</b></h5>

<table border="0" cellpadding="10">
<tr>

<tr>

<td><code><a href="docs/environment.html">environment.py</a></code></td>

<td>Abstract class for general reinforcement learning environments. Used
by <code><a href="docs/gridworld.html">gridworld.py</a></code>.</td>

</tr>

<tr>

<td><code><a href="docs/graphicsGridworldDisplay.html">graphicsGridworldDisplay.py</a></code></td>

<td>Gridworld graphical display.</td>

</tr>

<tr>

<td><code><a href="docs/graphicsUtils.html">graphicsUtils.py</a></code>
</td>

<td>Graphics utilities.</td>

</tr>

<tr>

<td><code><a href="docs/textGridworldDisplay.html">textGridworldDisplay.py</a></code></td>

<td>Plug-in for the Gridworld text interface.</td>

</tr>

<tr>

<td><code><a href="docs/crawler.html">crawler.py</a></code></td>

<td>The crawler code and test harness. You will run this but not edit it.</td>

</tr>

<tr>

<td><code><a href="docs/graphicsCrawlerDisplay.html">graphicsCrawlerDisplay.py</a></code></td>

<td>GUI for the crawler robot.</td>

</tr>


</tbody> </table>

<p>&nbsp; </p>

<p><strong>What to submit:</strong> You will fill in portions of <code><a href="docs/qlearningAgents.html">qlearningAgents.py</a></code> during the assignment. You should submit only these files.  Please don't change any others. Submit code and the analysis on t-square.</p>

<p><strong>Evaluation:</strong> You will be judged, as usual, on the one page analysis you write. Explain the Q-Learning algorithm. Change various parameters, ask as many questions you can and write a short analysis for the PacMan domain.</p>

<p>The deadline for this assignment is July 27, 2013 by 11:55 pm.</p>

<p>&nbsp;</p>

<h3>The rest of the assignment is left as an excercise.</h3>

<h3>MDPs</h3>

<p>To get started, run Gridworld in manual control mode, which uses the arrow keys:</p>

<pre>python gridworld.py -m</pre>

<p>You will see the two-exit layout from class.  The blue dot is the agent.  Note that when you press <em>up</em>, the agent only actually moves north 80% of the time.  Such is the life of a Gridworld agent!&nbsp;

 <p>You can control many aspects of the simulation.&nbsp;
 A full list of options is available by running:</p>

<pre> python gridworld.py -h</pre>

<p>The default agent moves randomly  </p>

<pre> python gridworld.py -g MazeGrid</pre>

<p>You should see the random agent bounce around the grid until it happens upon an exit.&nbsp;
   Not the finest hour for an AI agent.</p>

<p> <em>Note:</em> The Gridworld MDP is such that you first must enter a pre-terminal state (the double boxes shown in the GUI) and then take the special 'exit' action before the episode actually ends (in the true terminal state called <code>TERMINAL_STATE</code>, which is not shown in the GUI).&nbsp; If you run an episode manually, your total return may be less than you expected, due to the discount rate (<code>-d</code> to change; 0.9 by default).</p>

<p>Look at the console output that accompanies the graphical output (or use <code>-t</code> for all text).
    You will be told about each transition the agent experiences (to turn this off, use <code>-q</code>).&nbsp;</p>

<p>As in Pac-Man, positions are represented by <code>(x,y)</code> Cartesian coordinates
   and any arrays are indexed by <code>[x][y]</code>, with <code>'north'</code> being
	 the direction of increasing <code>y</code>, etc.&nbsp; By default,
	 most transitions will receive a reward of zero, though you can change this
	 with the living reward option (<code>-r</code>).&nbsp;</p>

<p><em><strong>Question 1 (6 points)&nbsp; </strong></em>Write a value iteration agent in <code>ValueIterationAgent</code>, which has been partially specified for you in <code><a href="docs/valueIterationAgents.html">valueIterationAgents.py</a></code>.&nbsp; Your value iteration agent is an offline planner, not a reinforcement agent, and so the relevant training option is the number of iterations of value iteration it should run (option <code>-i</code>) in its initial planning phase.&nbsp; <code>ValueIterationAgent</code> takes an MDP on construction and runs value iteration for the specified number of iterations before the constructor returns.

<p>Value iteration computes k-step estimates of the optimal values, V<sub>k</sub>.  In addition to running value iteration, implement the following methods for <code>ValueIterationAgent</code> using V<sub>k</sub>.
<ul>
    <li> <code>getValue(state)</code> returns the value of a state.
    <li> <code>getPolicy(state)</code> returns the best action according to computed values.
    <li> <code>getQValue(state, action)</code> returns the q-value of the (state, action) pair.&nbsp;
</ul>

<p> These quantities are all displayed in the GUI: values are numbers in squares, q-values are numbers in square quarters, and policies are arrows out from each square.

<p><em>Important:</em> Use the "batch" version of value iteration where each vector V<sub>k</sub> is computed from a fixed vector V<sub>k-1</sub> (like in lecture), not the "online" version where one single weight vector is updated in place.  The difference is discussed in <a href="http://www.cs.ualberta.ca/~sutton/book/ebook/node41.html">Sutton &amp; Barto</a> in the 6th paragraph of chapter 4.1.

<p><em>Note:</em> A policy synthesized from values of depth k (which reflect the next k rewards) will actually reflect the next k+1 rewards (i.e. you return &pi;<sub>k+1</sub>).  Similarly, the q-values will also reflect one more reward than the values (i.e. you return Q<sub>k+1</sub>).  You may assume that 100 iterations is enough for convergence in the questions below.

<p>The following command loads your <code>ValueIterationAgent</code>, which will compute a policy and execute it 10 times. Press a key to cycle through values, q-values, and the simulation.  You should find that the value of the start state  (<code>V(start)</code>) and the empirical resulting average reward are quite close.

<pre>python gridworld.py -a value -i 100 -k 10</pre>

<p><em>Hint:</em> On the default BookGrid, running value iteration for 5 iterations should give you this output:

<pre>python gridworld.py -a value -i 2</pre>

<center>
<img src="value_2.png" width="50%" alt="value iteration with k=5"/>
</center>

<pre>python gridworld.py -a value -i 3</pre>

<center>
<img src="value_3.png" width="50%" alt="value iteration with k=5"/>
</center>

<pre>python gridworld.py -a value -i 4</pre>

<center>
<img src="value_4.png" width="50%" alt="value iteration with k=5"/>
</center>

<pre>python gridworld.py -a value -i 5</pre>

<center>
<img src="value.png" width="50%" alt="value iteration with k=5"/>
</center>

<p>Your value iteration agent will be graded on a new grid.  We will check your values, q-values, and policies after fixed numbers of iterations and at convergence (e.g. after 100 iterations).

<p><em>Hint:</em> Use the <code>util.Counter</code> class in <code><a href="docs/util.html">util.py</a></code>,
   which is a dictionary with a default value of zero.  Methods such as <code>totalCount</code> should simplify your code.  However, be careful with <code>argMax</code>: the actual argmax you want may be a key not in the counter!</p>

<p><em><strong>Question 2 (1 point) </strong></em> On <code>BridgeGrid</code> with the default discount of 0.9 and the default noise of 0.2, the optimal policy does not cross the bridge.
Change only ONE of the discount and noise parameters so that the optimal policy causes the agent to attempt to cross the bridge.  Put your answer in <code>question2()</code> of <code><a href="docs/analysis.html">analysis.py</a></code>.  (Noise refers to how often an agent ends up in an unintended successor state when they perform an action.)&nbsp; The default corresponds to:

<pre>python gridworld.py -a value -i 100 -g BridgeGrid --discount 0.9 --noise 0.2</pre>

<p><em><strong>Question 3 (5 points) </strong></em> Consider
  the <code>DiscountGrid</code> layout, shown below. This grid has two
  terminal states with positive payoff (shown in green), a close exit
  with payoff +1 and a distant exit with payoff +10. The bottom row of
  the grid consists of terminal states with negative payoff (shown in
  red); each state in this "cliff" region has payoff -10. The starting
  state is the yellow square. We distinguish between two types of
  paths: (1) paths that "risk the cliff" and travel near the bottom
  row of the grid; these paths are shorter but risk earning a large
  negative payoff, and are represented by the red arrow in the figure
  below. (2) paths that "avoid the cliff" and travel along the top
  edge of the grid. These paths are longer but are less likely to
  incur huge negative payoffs. These paths are represented by the
  green arrow in the figure below.

<center>
<img src="discountgrid.png" width="50%" alt="DiscountGrid"/>
</center>

  <p> Give an assignment of parameter values for discount, noise, and
  livingReward which produce the following optimal policy types or
  state that the policy is impossible by returning the
  string <code>'NOT POSSIBLE'</code>.  The default corresponds to:

<pre>python gridworld.py -a value -i 100 -g DiscountGrid --discount 0.9 --noise 0.2 --livingReward 0.0</pre>

<ol type="a">

<li>Prefer the close exit (+1), risking the cliff (-10)</li>

<li>Prefer the close exit (+1), but avoiding the cliff (-10)</li>

<li>Prefer the distant exit (+10), risking the cliff (-10)</li>

<li>Prefer the distant exit (+10), avoiding the cliff (-10)</li>

<li>Avoid both exits (also avoiding the cliff)</li>
<br>
<br>
</ol>

	<code>question3a()</code> through <code>question3e()</code> should each return a 3-item tuple of (discount, noise, living reward) in <code><a href="docs/analysis.html">analysis.py</a></code>.

    <p><em>Note:</em> You can check your policies in the GUI.  For example, using a correct answer to 3(a), the arrow in (0,1) should point east, the arrow in (1,1) should also point east, and the arrow in (2,1) should point north.

<br>

<h3>Q-learning </h3>

<p>Note that your value iteration agent does not actually learn from experience.&nbsp; Rather, it ponders its MDP model to arrive at a complete policy before ever interacting with a real environment.&nbsp; When it does interact with the environment, it simply follows the precomputed policy (e.g. it becomes a reflex agent).  This distinction may be subtle in a simulated environment like a Gridword, but it's very important in the real world, where the real MDP is not available.&nbsp; </p>

<p><strong><em>Question 4 (5 points) </em></strong> You will now write a q-learning agent, which does very little on construction, but instead learns by trial and error from interactions with the environment through its <code>update(state, action, nextState, reward)</code> method.&nbsp; A stub of a q-learner is specified in <code>QLearningAgent</code> in <code><a href="docs/qlearningAgents.html">qlearningAgents.py</a></code>, and you can select it with the option <code>'-a q'</code>.  For this question, you must implement the <code>update</code>, <code>getValue</code>, <code>getQValue</code>, and <code>getPolicy</code> methods.

<p><em>Note:</em> For <code>getValue</code> and <code>getPolicy</code>, you should break ties randomly for better behavior. The <code>random.choice()</code> function will help.  In a particular state, actions that your agent <em>hasn't</em> seen before still have a Q-value, specifically a Q-value of zero, and if all of the actions that your agent <em>has</em> seen before have a negative Q-value, an unseen action may be optimal.</p>

<p><em>Important:</em> Make sure that you only access Q values by calling
  <code>getQValue</code> in
  your <code>getValue</code>, <code>getPolicy</code> functions. This
  abstraction will be useful for question 9 when you
  override <code>getQValue</code> to use features of state-action
  pairs rather than state-action pairs directly.

<p>With the q-learning update in place, you can watch your q-learner learn under manual control, using the keyboard:

<pre>python gridworld.py -a q -k 5 -m</pre>

Recall that <code>-k</code> will control the number of episodes your agent gets to learn.
Watch how the agent learns about the state it was just in, not the one it moves to, and "leaves learning in its wake."

<p><strong><em>Question 5 (2 points) </em></strong> Complete your q-learning agent by implementing epsilon-greedy action selection in <code>getAction</code>, meaning it chooses random actions epsilon of the time, and follows its current best q-values otherwise.

<pre>python gridworld.py -a q -k 100 </pre>

Your final q-values should resemble those of your value iteration agent, especially along well-traveled paths.  However, your average returns will be lower than the q-values predict because of the random actions and the initial learning phase.

<p> You can choose an element from a list uniformly at random by calling the <code>random.choice</code> function.
You can simulate a binary variable with probability <code>p</code>
of success by using <code>util.flipCoin(p)</code>, which returns <code>True</code> with
probability <code>p</code> and <code>False</code> with probability <code>1-p</code>.

<p><strong><em>Question 6 (1 points) </em></strong> First, train a completely random q-learner with the default learning rate on the noiseless BridgeGrid for 50 episodes and observe whether it finds the optimal policy.

<pre>python gridworld.py -a q -k 50 -n 0 -g BridgeGrid -e 1</pre>

Now try the same experiment with an epsilon of 0. Is there an epsilon and a learning rate for which it is highly likely (greater than 99%) that the optimal policy will be learned after 50 iterations? <code>question6()</code> should return EITHER a 2-item tuple of <code>(epsilon, learning rate)</code> OR the string <code>'NOT POSSIBLE'</code> if there is none.  Epsilon is controlled by <code>-e</code>, learning rate by <code>-l</code>.

<p><strong><em>Question 7 (1 point) </em></strong> With no additional code, you should now be able to run a q-learning crawler robot:

<pre> python crawler.py</pre>

If this doesn't work, you've probably written some code too specific to the <code>GridWorld</code> problem and you should make it more general to all MDPs.  You will receive full credit if the command above works without exceptions.

<p>This will invoke the crawling robot from class using your q-learner.&nbsp; Play around with the various learning parameters to see how they affect the agent's policies and actions.&nbsp;&nbsp; Note that the step delay is a parameter of the simulation, whereas the learning rate and epsilon are parameters of your learning algorithm, and the discount factor is a property of the environment. &nbsp;

<p><i>Congratulations!  You have a learning Pac-Man agent!</i>


</body> </html>
